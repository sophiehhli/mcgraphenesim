from shapely.geometry import Point
from shapely.geometry import LineString
import shapely
import matplotlib
import matplotlib.pyplot as plt

import numpy as np 

import point 
import boundary

def point_intersection(point, boundary): 
	"""use shapely library to calcualte tajectory/boundary intersections""" 
	line_string_coord = point.line_coordinates()
	trajectory = LineString(line_string_coord)
	multipoint = trajectory.intersection(boundary.reconstructed)
	"""uses if statements to deal with errors that are resolved""" 
	if isinstance(multipoint, shapely.geometry.MultiPoint)== True: 
		multiarray = [[p.x, p.y] for p in multipoint]
		if [point.x, point.y] in multiarray: 
			multiarray.remove([point.x, point.y])
		return multiarray[0]
	elif isinstance(multipoint, shapely.geometry.Point) == True: 
		return [multipoint.x, multipoint.y]
	else:
		print("Could not find the intersection")
		print('Coordinate: ' + str([point.x, point.y]))
		print('direction: ' + str(point.direction))
	return [multipoint.x, multipoint.y]

def closest_intersection(point, line_intersect, polygon): 
	shortest_dist = (line_intersect[0][1][0]-point.x)**2+(line_intersect[0][1][1]-point.y)**2
	closest_intersection = line_intersect[0]
	for line in line_intersect: 
		distance = (line[1][0]-point.x)**2+(line[1][1]-point.y)**2
		if distance < shortest_dist: 
			shortest_dist = distance 
			closest_intersection = line
	return closest_intersection

def polygon_intersection(point, polygon): 
	line_string_coord = point.line_coordinates()
	trajectory = LineString(line_string_coord)
	line_intersect = []
	for i in range(len(polygon.construct_lines)): 
		intersection = trajectory.intersection(polygon.construct_lines[i])
		if isinstance(intersection, shapely.geometry.Point) == True: 
			line_intersect.append([polygon.construct_lines[i], [intersection.x, intersection.y]])
	correct_intersection = closest_intersection(point, line_intersect, polygon)
	return correct_intersection

def specular_reflection(particle, n, intersection):
	"""collision with boundary, specular
	returns Particle type with new direction, position at intersection"""
	odir = particle.direction
	newdir = np.array(odir - 2 * (np.dot(odir,n)) * n)
	newparticle = point.Particle(intersection.coords, newdir)
	#particle.coords = intersection.coords
	#particle.direction = newdir 
	if particle.specie =='electron': 
		particle.k_vector.reflect()
	return newparticle 

theta_data = []

def sample_cos_dis(): 
	"""generates a point based on cosine distribution""" 
	usample = np.random.random() 
	neg = np.random.choice([-1, 1])
	theta = np.arcsin(usample) * neg
	"""error due to floating point errors in shapely library,
	must uncomment below for circular boundary so next intersection can be found""" 
	'''while np.rad2deg(theta) > 84 or np.rad2deg(theta) < -84: 
		usample = np.random.random() 
		neg = np.random.choice([-1, 1])
		theta = np.arcsin(np.sqrt(usample)) * neg
		#print('correction')
		#print(np.rad2deg(theta))'''
	return theta 

def diffuse_reflection(specie, n, intersection):
	"""uses cosine distribution to perform diffuse scattering
	output: new particle, position at the intersection, direction generated by cosine dist.""" 
	theta = sample_cos_dis()
	newdir = np.zeros(2)
	theta_data.append(theta)
	newdir[0] = np.cos(theta) * n[0] - np.sin(theta) * n[1]
	newdir[1] = np.sin(theta) * n[0] + np.cos(theta) * n[1]
	newparticle = point.Particle(intersection.coords, newdir, specie=specie) 
	if specie == 'electron': 
		particle.fermi_circle.randomize()
	return newparticle

def boundary_response(f, particle, boundary):
	"""used when collusion with boundary is found,
	either diffusively or specularly scattered"""
	intersection = Point(point_intersection(particle, boundary))
	normal =  intersection.normal(boundary)
	if np.random.random() < f: 
		return diffuse_reflection(particle.specie, normal, intersection)
	else:
		return specular_reflection(particle, normal, intersection)

def polygon_boundary_response(f, particle, polygon, contacts): 
	line, intersection = polygon_intersection(particle, polygon)
	intersection = point.Particle(intersection)
	normal = -1*polygon.grad(list(line.coords))
	if np.random.random() < f: 
		return diffuse_reflection(particle.specie, normal, intersection)
	else: 
		return specular_reflection(particle, normal, intersection)

def plot_trajectory(inital_point, new_point):
	"""add line connecting interaction points with line"""
	x_cords = [inital_point.x, new_point.x]
	y_cords = [inital_point.y, new_point.y]
	plt.plot(x_cords, y_cords, 'k-', lw=0.5)


def gen_line_point(start, end):
	'''generates a random point on a line'''
	a = [max(start[0], end[0]), max(start[1], end[1])]
	b = [min(start[0], end[0]), min(start[1], end[1])]
	x = (a[0] - b[0]) * np.random.random_sample() + b[0]
	if (start[0] - end[0]) == 0:
		y = (a[1] - b[1]) * np.random.random_sample() + b[1]
	else:
		gradient = (start[1] - end[1])/(start[0]- end[0])
		y = x * gradient + b[1]
	return point.Particle([x,y])

def contact_emmision(lead, specie):
	'''diffusive emission from a random point in the contact'''
	random_point = gen_line_point(lead.start, lead.end)
	return diffuse_reflection(specie, lead.normal, random_point)


def sample_cos_large_dist(n):
	"""produces array of point generated by cosine distribution"""
	theta_array = []
	i = 0
	while i <= n:
		theta_array.append(sample_cos_dis())
		i += 1
	return theta_array
